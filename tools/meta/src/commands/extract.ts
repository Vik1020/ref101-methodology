import { writeFileSync, mkdirSync, existsSync } from 'node:fs';
import { join, dirname } from 'node:path';
import YAML from 'yaml';
import { parseProcesses, getProjectRoot, namespaceExists, getAvailableNamespaces } from '../lib/parser.js';
import { mapProcessToMethodology } from '../lib/mapper.js';
import type { Methodology } from '../lib/types.js';

interface ExtractOptions {
  output?: string;
  dryRun?: boolean;
}

export async function extractCommand(namespace: string, options: ExtractOptions): Promise<void> {
  console.log(`\nExtracting methodology from namespace: ${namespace}\n`);

  // Validate namespace exists
  if (!namespaceExists(namespace)) {
    const available = getAvailableNamespaces();
    console.error(`Error: Namespace '${namespace}' not found.`);
    console.error(`Available namespaces: ${available.join(', ')}`);
    process.exit(1);
  }

  // Parse processes
  console.log('Parsing processes...');
  const processes = parseProcesses(namespace);

  if (processes.length === 0) {
    console.error('Error: No processes found in namespace.');
    process.exit(1);
  }

  console.log(`  Found ${processes.length} process(es): ${processes.map(p => p.process_id).join(', ')}`);

  // Map to methodology
  console.log('\nMapping to meta-methodology elements...');
  const methodology = mapProcessToMethodology(processes, namespace);

  // Print summary
  printSummary(methodology);

  // Output
  const outputPath = options.output ||
    join(getProjectRoot(), 'meta', 'generated', `${namespace}.methodology.yaml`);

  if (options.dryRun) {
    console.log('\n--- DRY RUN: Generated YAML ---\n');
    console.log(YAML.stringify(methodology, { lineWidth: 120 }));
    return;
  }

  // Ensure output directory exists
  const outputDir = dirname(outputPath);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Write file
  const yamlContent = generateYamlWithComments(methodology);
  writeFileSync(outputPath, yamlContent, 'utf-8');

  console.log(`\nâœ“ Methodology extracted to: ${outputPath}`);
  console.log('\nNext steps:');
  console.log('  1. Review the generated file');
  console.log('  2. Run validation: node dist/index.js validate ' + namespace);
  console.log('  3. Address any warnings');
  console.log('  4. Copy to namespaces/' + namespace + '/methodology.yaml when ready');
}

function printSummary(methodology: Methodology): void {
  console.log('\n--- Extraction Summary ---');
  console.log(`  States:    ${methodology.states.length}`);
  console.log(`  Actors:    ${methodology.actors.length}`);
  console.log(`  Tools:     ${methodology.tools?.length || 0}`);
  console.log(`  Actions:   ${methodology.actions.length}`);
  console.log(`  Artifacts: ${methodology.artifacts?.length || 0}`);
  console.log(`  Facts:     ${methodology.facts.length}`);
  console.log(`  Rules:     ${methodology.rules?.length || 0}`);
  console.log(`  Processes: ${methodology.processes?.length || 0}`);

  // Show state types
  const statesByType = methodology.states.reduce((acc, s) => {
    acc[s.type] = (acc[s.type] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  console.log('\n  State types:');
  for (const [type, count] of Object.entries(statesByType)) {
    console.log(`    - ${type}: ${count}`);
  }

  // Show actors
  console.log('\n  Actors:');
  for (const actor of methodology.actors) {
    console.log(`    - ${actor.name} (${actor.type})`);
  }
}

function generateYamlWithComments(methodology: Methodology): string {
  const header = `# =============================================================================
# METHODOLOGY: ${methodology.name}
# =============================================================================
# Generated by ref101-meta extract on ${new Date().toISOString().split('T')[0]}
#
# This file describes the ${methodology.methodology_id} methodology using the
# 8 elements of meta-methodology v${methodology.meta_version}:
#   State, Actor, Tool, Action, Entity, Artifact, Fact, Rule
#
# For documentation, see: meta/README.md
# =============================================================================

`;

  const yaml = YAML.stringify(methodology, {
    lineWidth: 120,
    defaultKeyType: 'PLAIN',
    defaultStringType: 'QUOTE_DOUBLE',
  });

  // Add section comments
  const sectioned = yaml
    .replace(/^entities:/m, '\n# === ENTITIES (Business objects passing through States) ===\nentities:')
    .replace(/^states:/m, '\n# === STATES (Lifecycle phases) ===\nstates:')
    .replace(/^actors:/m, '\n# === ACTORS (Executors: Human, AI, System) ===\nactors:')
    .replace(/^tools:/m, '\n# === TOOLS (Instruments for Actions) ===\ntools:')
    .replace(/^actions:/m, '\n# === ACTIONS (Units of work) ===\nactions:')
    .replace(/^artifacts:/m, '\n# === ARTIFACTS (Files/documents created) ===\nartifacts:')
    .replace(/^facts:/m, '\n# === FACTS (Events triggering transitions) ===\nfacts:')
    .replace(/^rules:/m, '\n# === RULES (Constraints and conditions) ===\nrules:')
    .replace(/^processes:/m, '\n# === PROCESSES (Predefined State compositions) ===\nprocesses:');

  return header + sectioned;
}
